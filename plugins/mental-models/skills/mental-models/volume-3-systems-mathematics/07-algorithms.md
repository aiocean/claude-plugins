# Algorithms

> "An algorithm is a recipe for guaranteed results."

## Core Concept

An **Algorithm** is a step-by-step procedure for solving a problem or accomplishing a task. Given the same inputs, it produces the same outputs—reliably and predictably.

As a mental model, algorithms represent systematic approaches that remove guesswork and ensure consistency.

## The Fundamental Truth

When you have a reliable algorithm, you don't need to think every time:
- Follow the steps
- Get the result
- Repeat with confidence

This frees mental energy for problems that actually require thinking.

## Properties of Good Algorithms

### 1. Defined Input
Clear specification of what goes in:
- What information is needed?
- In what format?
- What conditions must be met?

### 2. Defined Output
Clear specification of what comes out:
- What result is produced?
- In what format?
- What guarantees are made?

### 3. Finite Steps
The procedure terminates:
- Not an endless loop
- Eventually produces an answer
- Time-bounded

### 4. Unambiguous Instructions
Each step is clear:
- No interpretation needed
- Anyone could follow
- Reproducible by others

### 5. Correctness
Produces the right result:
- Given valid input
- Under specified conditions
- Reliably every time

## Algorithms in Daily Life

### Morning Routine Algorithm

```
1. Wake at alarm
2. Immediately stand up (don't hit snooze)
3. Drink glass of water
4. 5-minute stretch
5. Shower (cold finish)
6. Dress (clothes laid out night before)
7. Breakfast (pre-prepared)
8. Review day's priorities
9. Begin first task
```

**Benefit:** No decision fatigue about what to do next.

### Decision-Making Algorithm

For major decisions:
```
1. Define the decision clearly
2. List all viable options
3. Identify key criteria (max 5)
4. Score each option on each criterion
5. Weight the criteria by importance
6. Calculate weighted scores
7. Check result against intuition
8. If conflict, investigate why
9. Make decision
10. Define success criteria and review date
```

### Debugging Algorithm

```
1. Reproduce the problem consistently
2. Identify when it started (last known good state)
3. List what changed since then
4. Test each change in isolation
5. Find the minimal reproducing case
6. Form hypothesis about cause
7. Test hypothesis
8. If confirmed, fix and verify
9. If not, return to step 6 with new hypothesis
```

## Benefits of Algorithms

### 1. Consistency
Same process every time:
- Removes variation
- Builds habits
- Creates reliability

### 2. Reduced Cognitive Load
Don't have to think:
- Saves mental energy
- Reduces decision fatigue
- Frees attention for exceptions

### 3. Delegation
Others can follow:
- Training is simpler
- Quality is maintained
- Scaling is possible

### 4. Improvement
Can be optimized:
- Measure performance
- Identify bottlenecks
- Iterate the process

### 5. Error Reduction
Fewer mistakes:
- Steps aren't skipped
- Edge cases are handled
- Quality is systematic

## Building Your Algorithms

### Step 1: Identify Recurring Problems
What do you do repeatedly that would benefit from a systematic approach?

### Step 2: Document Current Process
How do you currently do it? What are all the steps?

### Step 3: Optimize the Process
- Remove unnecessary steps
- Clarify ambiguous steps
- Handle edge cases
- Add checkpoints

### Step 4: Test the Algorithm
Run through it several times:
- Does it work?
- Is it complete?
- Is it clear?

### Step 5: Iterate
Refine based on experience:
- What breaks?
- What's slow?
- What can be improved?

## Algorithm Categories

### Deterministic Algorithms
Same input → Same output every time
- Calculation procedures
- Sorting methods
- Lookup processes

### Heuristic Algorithms
Rules of thumb that usually work
- 80/20 prioritization
- "If X then probably Y"
- Approximate solutions

### Adaptive Algorithms
Adjust based on results
- A/B testing
- Machine learning
- Feedback-based improvement

## Warning: When Algorithms Fail

### Novel Situations
Algorithms are for known problems:
- New problems need new solutions
- Don't force algorithmic thinking where creativity is needed

### Changing Conditions
Algorithms assume stable conditions:
- Update algorithms when context changes
- Don't follow outdated procedures

### Edge Cases
Algorithms may not cover everything:
- Build in exception handling
- Know when to override

### Over-Systematization
Not everything needs an algorithm:
- Some things benefit from intuition
- Relationships aren't algorithmic
- Creative work resists systematization

## Key Algorithms to Develop

| Life Area | Algorithm For |
|-----------|--------------|
| **Morning** | Starting the day right |
| **Evening** | Winding down, preparing for tomorrow |
| **Work** | Deep work sessions |
| **Decisions** | Major life/career choices |
| **Conflict** | Handling disagreements |
| **Learning** | Acquiring new skills |
| **Problem-solving** | Approaching challenges |
| **Health** | Exercise, meals, sleep |

## Key Takeaways

1. **Algorithms provide consistency** - Same process, reliable results
2. **Reduce cognitive load** - Don't rethink solved problems
3. **Enable delegation** - Others can follow the process
4. **Are improvable** - Systematize, measure, optimize
5. **Have limits** - Know when to override or adapt

## The Algorithm Questions

- **"What recurring problems could I systematize?"**
- **"What's my algorithm for X?"**
- **"Is this algorithm still working?"**
- **"What's the exception process?"**

## Related Models

- **Checklists** - A form of algorithm
- **Systems** - Algorithms operate within systems
- **Feedback Loops** - Improve algorithms based on results

---

*"For every complex problem, there is a solution that is clear, simple, and wrong."*
— H.L. Mencken

*But for many routine problems, there is indeed a clear, simple, and right algorithm. Find those.*
